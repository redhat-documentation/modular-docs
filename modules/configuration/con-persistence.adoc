[id='con-persistence_{context}']
= Persistence in {PRODUCT} services

{PRODUCT} supports runtime persistence for preserving process data in your services across application restarts. {PRODUCT} persistence is based on https://infinispan.org/[Infinispan] and enables you to configure key-value storage definitions to persist data, such as active process nodes and process instance variables.

Runtime persistence is intended primarily for storing data that is required to resume workflow execution for a particular process instance. Persistence applies to both public and private processes that are not yet complete. Once a process completes, persistence is no longer applied. This persistence behavior means that only the information that is required to resume execution is persisted.

Node instances that are currently active or in wait states are persisted. When a process instance finishes execution but has not reached the end state (completed or aborted), the node instance data is persisted.

== Persistence workflow in {PRODUCT}

In {PRODUCT}, a process instance is persisted when the process reaches a wait state, where the process does not execute anymore but has not reached the end state (completed or aborted).

For example, when a process reaches a user task or a catching signal event, the process instances pauses and the {PRODUCT} {PROCESS_ENGINE} takes a complete snapshot of the process, including the following data:

* Process instance metadata, such as process instance ID, process definition ID, state, description, and start date
* Process instance variables
* Active node instances, including local variables

Process instance metadata is persisted with a predefined protobuf (https://developers.google.com/protocol-buffers/[protocol buffers]) schema that is aware of the metadata and supports node instances that are in wait states.

Process instance and node instance variables are persisted based on the generated protobuf schema and generated marshallers. Custom data types are also persisted during execution.

For straight-through process instances that do not trigger any activity, persistence is not invoked and no data is stored.

Each process definition has its own cache for storing runtime information. The cache is based on the process definition ID and is named in the Infinispan server. If no process cache exists, cache is automatically created in Infinispan. This setup facilitates maintenance of process instance data and reduces concurrency on the cache instances.

== Persisted process instance variables and data types

Persisted process variables, local variables, and other process data are stored with the process instance. The stored data is marshalled into bytes format so it can be transferred and persisted into the key-value storage definition. The marshalling and unmarshalling is implemented based on protobuf (https://developers.google.com/protocol-buffers/[protocol buffers]) and requires a schema and marshallers for handling a specified type of data.

{PRODUCT} generates both the protobuf schema (as PROTO files) and marshallers for persisting variables. The {PRODUCT} marshallers are based on the https://github.com/infinispan/protostream[ProtoStream] subproject of Infinispan.

When you build your {PRODUCT} project, {PRODUCT} scans all process definitions and extracts information about the data within the business assets. Based on the unique data types (regardless of how many processes reference a specified type), a PROTO file called `kogito-application.proto` is generated that builds a complete schema for the application. This file is stored in the `target/classes/persistence/` folder of your project after successful build.

.Example PROTO file generated by {PRODUCT} to persist process data
[source]
----
syntax = "proto2";
package org.kie.kogito.examples;
import "kogito-types.proto";

message Order {
        option java_package = "org.kie.kogito.examples.demo";
        optional string orderNumber = 1;
        optional bool shipped = 2;
        optional double total = 3;
}
message Person {
        option java_package = "org.kie.kogito.examples.demo";
        optional bool adult = 1;
        optional int32 age = 2;
        optional string name = 3;
}
----

NOTE: Each `kogito-application.proto` file imports a `kogito-types.proto` file that automatically defines the base types managed by {PRODUCT}.

Based on the `kogito-application.proto` file, marshallers are also generated and configured in the application so that whenever a particular data type is used in a process instance, the data is successfully marshalled and unmarshalled.

== Supported data types for persisted variables

For optimal persistence with process data and variables, use Java objects as data types that represent your process variables. If you use other formats for data types, your data might not be persisted or your {PRODUCT} project might fail to compile.

{PRODUCT} currently supports the following data types for process variables:

.Supported data types
[cols="30%,70%", options="header"]
|===
|Data type |Description

|`java.lang.String`
|Basic text type

|`java.lang.Integer`
|Basic number type

|`java.lang.Long`
|Extended size number type

|`java.lang.Float`
|Basic floating point number type

|`java.lang.Double`
|Extended size floating point number type

|`java.util.Date`
|Basic date type

|Java object
|Custom data type built with multiple simple types

|Java object with a Java object
|Custom data type built with multiple simple types and includes another Java object

|Java object with a list of Java objects
|Custom data type built with multiple simple types and a list of Java objects, and can also contain another Java object
|===
